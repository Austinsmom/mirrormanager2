#!/usr/bin/python
__requires__ = 'TurboGears[future]'
import pkg_resources
pkg_resources.require("TurboGears")

import datetime as dt
import logging
from optparse import OptionParser
import os
from subprocess import Popen
import sys
import time

import turbogears

sys.path.append('/usr/share/mirrormanager/server')
from mirrormanager.model import Host
from mirrormanager.lib import manage_pidfile, remove_pidfile

pidfile='/var/run/mirrormanager/crawler.pid'
options = None

from turbogears.database import PackageHub
hub = __connection__ = None
logger = None

class ForkingMaster:
    def __init__(self, max_children = 10):
        self.active_children = None
        self.max_children = max_children
        self.devnull = open('/dev/null', 'rw')
        self.timings = {}

    def collect_children(self):
        """Internal routine to wait for died children."""
        while self.active_children:
            if len(self.active_children) < self.max_children:
                options = os.WNOHANG
            else:
                # If the maximum number of children are already
                # running, block while waiting for a child to exit
                options = 0
            try:
                pid, status = os.waitpid(0, options)
            except os.error:
                pid = None
            if not pid: break
            self.active_children.remove(pid)
            self.stop_time(pid)

    def process_request(self, command, args, host):
        """Fork a new subprocess to process the request."""
        self.collect_children()
        logging.info("Starting crawler %s: %s" % (host.name, args))
        p = Popen(args, executable=command, stdin=self.devnull, stdout=self.devnull, stderr=self.devnull, close_fds=True)
        self.start_time(p.pid, host.id)
        # Parent process
        if self.active_children is None:
            self.active_children = []
        self.active_children.append(p.pid)

    def wait_for_completion(self):
        self.max_children = 0
        self.collect_children()

    def start_time(self, pid, hostid):
        self.timings[pid] = dict()
        self.timings[pid]['start'] = dt.datetime.utcnow()
        self.timings[pid]['hostid'] = hostid

    def stop_time(self, pid):
        self.timings[pid]['stop'] = dt.datetime.utcnow()

        diff = self.timings[pid]['stop'] - self.timings[pid]['start']
        host = Host.get(self.timings[pid]['hostid'])
        logger.info('Host %s (id=%s) crawl time %s' % (host.name, host.id, str(diff)))
        del self.timings[pid]

def doit():
    master = ForkingMaster(max_children=options.threads)
    command = '/usr/share/mirrormanager/server/crawler_perhost'
    commonargs = [ command, '-c', options.config, '--timeout-minutes', '90']
    if options.canary:
        commonargs.append('--canary')


    numhosts = Host.selectBy(private=False).count()
    i = 0
    for h in Host.selectBy(private=False).orderBy('id'):
        i += 1
        try:
            if not (h.admin_active and h.user_active and h.site.user_active and h.site.admin_active):
                continue
            if h.site.private:
                continue
            
            hostargs = []
            hostargs.extend(['--hostid', str(h.id)])
            logfilename = os.path.join(options.logdir, str(h.id) + '.log')
            hostargs.extend(['--logfile', logfilename])
            args = commonargs + hostargs
            logger.debug('starting crawler for host %s (id=%d) %d/%d' % (h.name, h.id, i, numhosts))
            master.process_request(command, args, h)
        except AssertionError: # someone deleted our host while we were looking at it
            continue
        
    master.wait_for_completion()

def setup_logger():
    fmt = "%(asctime)s %(message)s"
    formatter = logging.Formatter(fmt=fmt)
    formatter.converter = time.gmtime
    logger = logging.getLogger('crawler')
    handler = logging.handlers.WatchedFileHandler(options.logfile, "a+b")
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.DEBUG)
    return logger

def main():
    global options
    if manage_pidfile(pidfile):
        print "another instance is running, try again later."
        return 1

    parser = OptionParser(usage=sys.argv[0] + " [options]")
    parser.add_option("-c", "--config",
                      dest="config", default='dev.cfg',
                      help="TurboGears config file to use")

    parser.add_option("--include-private",
                      action="store_true", dest="include_private", default=False,
                      help="Include hosts marked 'private' in the crawl")

    parser.add_option("-t", "--threads", type="int",
                      dest="threads", default=10,
                      help="max threads to start in parallel")
    parser.add_option("-l", "--logdir", type="string", metavar="DIR",
                      dest="logdir", default='/var/log/mirrormanager/crawler',
                      help="write individual host logfiles to DIR")
    parser.add_option("--logfile", type="string", metavar="FILE",
                      dest="logfile", default='/var/log/mirrormanager/crawler.log',
                      help="write logfile to FILE")

    parser.add_option("--canary", 
                      dest="canary", action="store_true", default=False,
                      help="fast crawl by only scanning for canary files")

    (options, args) = parser.parse_args()

    turbogears.update_config(configfile=options.config,
                             modulename="mirrormanager.config")
    global hub
    global __connection__
    hub = PackageHub("mirrormanager")
    __connection__ = hub

    global logger
    logger = setup_logger()
    
    doit()
    remove_pidfile(pidfile)
    return 0

if __name__ == "__main__":
    sys.exit(main())
